initSidebarItems({"fn":[["clear_message","Clear the message in the echo area. If the prompt was saved with a call to `rl_save_prompt` before the last call to `rl_message`, call `rl_restore_prompt` before calling this function."],["crlf","Move the cursor to the start of the next screen line."],["expand_prompt","Expand any special character sequences in prompt and set up the local Readline prompt redisplay variables. This function is called by `readline()`. It may also be called to expand the primary prompt if the `rl_on_new_line_with_prompt()` function or `rl_already_prompted` variable is used. It returns the number of visible characters on the last line of the (possibly multi-line) prompt. Applications may indicate that the prompt contains characters that take up no physical screen space when displayed by bracketing a sequence of such characters with the special markers **RL_PROMPT_START_IGNORE** and **RL_PROMPT_END_IGNORE** (declared in `readline.h'. This may be used to embed terminal-specific escape sequences in prompts."],["forced_update_display","Force the line to be updated and redisplayed, whether or not Readline thinks the screen display is correct."],["message","The arguments are a format string as would be supplied to printf, possibly containing conversion specifications such as `%d', and any additional arguments necessary to satisfy the conversion specifications. The resulting string is displayed in the echo area. The echo area is also used to display numeric arguments and search strings. You should call `rl_save_prompt` to save the prompt information before calling this function."],["on_new_line","Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline."],["on_new_line_with_prompt","Tell the update functions that we have moved onto a new line, with `rl_prompt` already displayed. This could be used by applications that want to output the prompt string themselves, but still need Readline to know the prompt string length for redisplay. It should be used after setting `rl_already_prompted`."],["redisplay","Change what's displayed on the screen to reflect the current contents of `rl_line_buffer`."],["reset_line_state","Reset the display state to a clean state and redisplay the current line starting on a new line."],["rl_restore_prompt","Restore the local Readline prompt display state saved by the most recent call to `rl_save_prompt`.  If `rl_save_prompt` was called to save the prompt before a call to `rl_message`, this function should be called before the corresponding call to `rl_clear_message`."],["save_prompt","Save the local Readline prompt display state in preparation for displaying a new message in the message area with `rl_message()`."],["set_prompt","Make Readline use prompt for subsequent redisplay. This calls `rl_expand_prompt()`` to expand the prompt and sets `rl_prompt` to the result."],["show_char","Display character `c` on `rl_outstream`. If Readline has not been set to display meta characters directly, this will convert meta characters to a meta-prefixed key sequence. This is intended for use by applications which wish to do their own redisplay."]]});