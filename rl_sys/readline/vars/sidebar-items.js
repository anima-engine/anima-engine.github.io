initSidebarItems({"constant":[["RL_STATE_CALLBACK","Readline is currently using the alternate (callback) interface (see section [2.4.12 Alternate Interface]). [2.4.12 alternate interface]: https://goo.gl/PHb4Kq"],["RL_STATE_COMPLETING","Readline is performing word completion."],["RL_STATE_DISPATCHING","Readline is dispatching to a command."],["RL_STATE_DONE","Readline has read a key sequence bound to `accept-line` and is about to return the line to the caller."],["RL_STATE_INITIALIZED","Readline has completed its initialization."],["RL_STATE_INITIALIZING","Readline is initializing its internal data structures."],["RL_STATE_INPUTPENDING","Readline has input pending due to a call to `rl_execute_next()`."],["RL_STATE_ISEARCH","Readline is performing an incremental history search."],["RL_STATE_MACRODEF","Readline is currently reading characters defining a keyboard macro."],["RL_STATE_MACROINPUT","Readline is currently getting its input from a previously-defined keyboard macro."],["RL_STATE_METANEXT","Readline is reading more input after reading the meta-prefix character."],["RL_STATE_MOREINPUT","Readline is reading more input while executing an editing command."],["RL_STATE_MULTIKEY","Readline is reading a multiple-keystroke command."],["RL_STATE_NONE","Readline has not yet been called, nor has it begun to initialize."],["RL_STATE_NSEARCH","Readline is performing a non-incremental history search."],["RL_STATE_NUMERICARG","Readline is reading a numeric argument."],["RL_STATE_OVERWRITE","Readline is in overwrite mode."],["RL_STATE_READCMD","Readline is reading a command from the keyboard."],["RL_STATE_SEARCH","Readline is searching backward or forward through the history for a string."],["RL_STATE_SIGHANDLER","Readline is currently executing the readline signal handler."],["RL_STATE_TERMPREPPED","Readline has modified the terminal modes to do its own input and redisplay."],["RL_STATE_TTYCSAVED","Readline has saved the values of the terminal's special characters."],["RL_STATE_UNDOING","Readline is performing an undo."],["RL_STATE_VICMDONCE","Readline has entered vi command (movement) mode at least one time during the current call to `readline()`."],["RL_STATE_VIMOTION","Readline is reading the argument to a vi-mode \"motion\" command."]],"fn":[["get_library_version","The version number of this revision of the library."],["get_state","Get the Readline state flags."]],"static":[["rl_already_prompted","If an application wishes to display the prompt itself, rather than have Readline do it the first time `readline()` is called, it should set this variable to a non-zero value after displaying the prompt. The prompt must also be passed as the argument to `readline()` so the redisplay functions can update the display properly. The calling application is responsible for managing the value; Readline never sets it."],["rl_binding_keymap","This variable is set to the keymap (see section [2.4.2 Selecting a Keymap]) in which the last key binding occurred. [2.4.2 selecting a keymap]: https://goo.gl/WMVvss"],["rl_deprep_term_function","If non-zero, Readline will call indirectly through this pointer to reset the terminal. This function should undo the effects of `rl_prep_term_function`. By default, this is set to `rl_deprep_terminal` (see section [2.4.9 Terminal Management]). [2.4.9 terminal management]: https://goo.gl/1xVE8y"],["rl_dispatching","Set to a non-zero value if a function is being called from a key binding; zero otherwise. Application functions can test this to discover whether they were called directly or by Readline's dispatching mechanism."],["rl_display_prompt","The string displayed as the prompt. This is usually identical to `rl_prompt`, but may be changed temporarily by functions that use the prompt string as a message area, such as incremental search."],["rl_done","Setting this to a non-zero value causes Readline to return the current line immediately."],["rl_editing_mode","Set to a value denoting Readline's current editing mode. A value of 1 means Readline is currently in emacs mode; 0 means that vi mode is active."],["rl_end","The number of characters present in `rl_line_buffer`. When `rl_point` is at the end of the line, `rl_point` and `rl_end` are equal."],["rl_erase_empty_line","Setting this to a non-zero value causes Readline to completely erase the current line, including any prompt, any time a newline is typed as the only character on an otherwise-empty line. The cursor is moved to the beginning of the newly-blank line."],["rl_event_hook","If non-zero, this is the address of a function to call periodically when Readline is waiting for terminal input. By default, this will be called at most ten times a second if there is no keyboard input."],["rl_executing_key","The key that caused the dispatch to the currently-executing Readline function."],["rl_executing_keymap","This variable is set to the keymap (see section [2.4.2 Selecting a Keymap]) in which the currently executing readline function was found. [2.4.2 selecting a keymap]: https://goo.gl/WMVvss"],["rl_executing_keyseq","The full key sequence that caused the dispatch to the currently-executing Readline function."],["rl_executing_macro","This variable is set to the text of any currently-executing macro."],["rl_explicit_arg","Set to a non-zero value if an explicit numeric argument was specified by the user. Only valid in a bindable command function."],["rl_getc_function","If non-zero, Readline will call indirectly through this pointer to get a character from the input stream. By default, it is set to `rl_getc`, the default Readline character input function (see section [2.4.8 Character Input]). In general, an application that sets `rl_getc_function` should consider setting `rl_input_available_hook` as well. [2.4.8 character input]: https://goo.gl/olQQLc"],["rl_gnu_readline_p","Always set to 1, denoting that this is GNU readline rather than some emulation."],["rl_input_available_hook","If non-zero, Readline will use this function's return value when it needs to determine whether or not there is available input on the current input source. The default hook checks `rl_instream`; if an application is using a different input source, it should set the hook appropriately. Readline queries for available input when implementing intra-key-sequence timeouts during input and incremental searches. This may use an application-specific timeout before returning a value; Readline uses the value passed to `rl_set_keyboard_input_timeout()` or the value of the user-settable `keyseq-timeout` variable. This is designed for use by applications using Readline's callback interface (see section [2.4.12 Alternate Interface]), which may not use the traditional `read(2)` and file descriptor interface, or other applications using a different input mechanism. If an application uses an input mechanism or hook that can potentially exceed the value of `keyseq-timeout`, it should increase the timeout or set this hook appropriately even when not using the callback interface. In general, an application that sets `rl_getc_function` should consider setting `rl_input_available_hook` as well. [2.4.12 alternate interface]: https://goo.gl/PHb4Kq"],["rl_instream","The stdio stream from which Readline reads input. If NULL, Readline defaults to stdin."],["rl_key_sequence_length","The number of characters in `rl_executing_keyseq`."],["rl_last_command_func","The address of the last command function Readline executed. May be used to test whether or not a function is being executed twice in succession, for example."],["rl_line_buffer","This is the line gathered so far. You are welcome to modify the contents of the line, but see [2.4.5 Allowing Undoing]. The function `rl_extend_line_buffer` is available to increase the memory allocated to `rl_line_buffer`. [2.4.5 allowing undoing]: https://goo.gl/oYj9bq"],["rl_mark","The mark (saved position) in the current line. If set, the mark and point define a region."],["rl_num_chars_to_read","Setting this to a positive value before calling `readline()` causes Readline to return after accepting that many characters, rather than reading up to a character bound to `accept-line`."],["rl_numeric_arg","Set to the value of any numeric argument explicitly specified by the user before executing the current Readline function. Only valid in a bindable command function."],["rl_outstream","The stdio stream to which Readline performs output. If NULL, Readline defaults to stdout."],["rl_pending_input","Setting this to a value makes it the next keystroke read. This is a way to stuff a single character into the input stream."],["rl_point","The offset of the current cursor position in `rl_line_buffer` (the *point*)."],["rl_pre_input_hook","If non-zero, this is the address of a function to call after the first prompt has been printed and just before `readline` starts reading input characters."],["rl_prefer_env_winsize","If non-zero, Readline gives values found in the LINES and COLUMNS environment variables greater precedence than values fetched from the kernel when computing the screen dimensions."],["rl_prep_term_function","If non-zero, Readline will call indirectly through this pointer to initialize the terminal. The function takes a single argument, an int flag that says whether or not to use eight-bit characters. By default, this is set to `rl_prep_terminal` (see section [2.4.9 Terminal Management]). [2.4.9 terminal management]: https://goo.gl/1xVE8y"],["rl_prompt","The prompt Readline uses. This is set from the argument to `readline()`, and should not be assigned to directly. The `rl_set_prompt()` function (see section [2.4.6 Redisplay]) may be used to modify the prompt string after calling `readline()`. [2.4.6 redisplay]: https://goo.gl/aTbhPU"],["rl_readline_name","This variable is set to a unique name by each application using Readline. The value allows conditional parsing of the inputrc file (see section [1.3.2 Conditional Init Constructs]). [1.3.2 conditional init constructs]: https://goo.gl/ENcVC5"],["rl_readline_version","An integer encoding the current version of the library. The encoding is of the form 0xMMmm, where MM is the two-digit major version number, and mm is the two-digit minor version number. For example, for Readline-4.2, `rl_readline_version` would have the value 0x0402."],["rl_redisplay_function","If non-zero, Readline will call indirectly through this pointer to update the display with the current contents of the editing buffer. By default, it is set to `rl_redisplay`, the default Readline redisplay function (see section [2.4.6 Redisplay]). [2.4.6 redisplay]: https://goo.gl/aTbhPU"],["rl_signal_event_hook","If non-zero, this is the address of a function to call if a read system call is interrupted when Readline is reading terminal input."],["rl_startup_hook","If non-zero, this is the address of a function to call just before `readline` prints the first prompt."],["rl_terminal_name","The terminal type, used for initialization. If not set by the application, Readline sets this to the value of the TERM environment variable the first time it is called."]],"struct":[["ReadlineState","Readline State Bitflags"]]});